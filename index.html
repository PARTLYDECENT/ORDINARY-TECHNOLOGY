<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ORDINARY TECHNOLOGY ACCESS PANEL</title>
  <base href="https://partlydecent.github.io/GAMEHUBORDINARY/" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #6A00FF;
      --secondary: #00FFCC;
      --accent: #3300CC;
      --background: #050511;
      --text: #FFFFFF;
    }
    * {margin: 0; padding: 0; box-sizing: border-box;}
    body {
      font-family: 'Space Grotesk', sans-serif;
      background-color: var(--background);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
    }
    #webglCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    .noise-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: url('data:image/png;base64,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');
      opacity: 0.03;
      z-index: -1;
      pointer-events: none;
    }
    .container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      position: relative;
      z-index: 1;
    }
    h1 {
      font-size: clamp(2rem, 5vw, 3.5rem);
      text-align: center;
      letter-spacing: 2px;
      line-height: 1.2;
      font-weight: 600;
      margin-bottom: 0.5rem;
      background: linear-gradient(to right, var(--secondary), var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: textGlow 8s ease-in-out infinite;
    }
    h1:nth-child(2) {
      font-size: clamp(1.5rem, 3vw, 2.5rem);
      margin-bottom: 3rem;
    }
    .beta {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      background: var(--accent);
      color: var(--text);
      padding: 0.25rem 0.75rem;
      font-size: 0.8rem;
      border-radius: 20px;
      letter-spacing: 1px;
      box-shadow: 0 0 20px rgba(51, 0, 204, 0.5);
    }
    .button-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
      width: 100%;
      max-width: 800px;
    }
    .button {
      background: rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--text);
      padding: 1.2rem;
      font-size: 1rem;
      letter-spacing: 1px;
      text-transform: uppercase;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 400;
    }
    .button::before {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transform: translateX(-100%);
      transition: transform 0.6s ease;
    }
    .button:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
    }
    .button:hover::before {transform: translateX(100%);}
    .play-button {border-left: 3px solid var(--secondary);}
    .ai-button {
      border-left: 3px solid var(--accent);
      background: linear-gradient(45deg, rgba(51, 0, 204, 0.1), rgba(0, 0, 0, 0.2));
    }
    .console {
      position: fixed;
      bottom: 2rem;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      z-index: 10;
    }
    #consoleInput {
      width: 90%;
      max-width: 800px;
      padding: 1rem 1.5rem;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: var(--text);
      font-family: 'Space Grotesk', monospace;
      font-size: 1rem;
      letter-spacing: 1px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    #consoleInput:focus {
      outline: none;
      border-color: var(--secondary);
      box-shadow: 0 0 0 2px rgba(0, 255, 204, 0.2);
    }
    .warp-distortion {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(circle, transparent 20%, black 100%);
      opacity: 0;
      z-index: 100;
      animation: warpEffect 1.5s ease-out;
      pointer-events: none;
    }
    @keyframes warpEffect {
      0% {opacity: 0; transform: scale(0);}
      50% {opacity: 0.8; transform: scale(1.5);}
      100% {opacity: 0; transform: scale(2);}
    }
    @keyframes textGlow {
      0%, 100% {filter: drop-shadow(0 0 10px rgba(106, 0, 255, 0.5));}
      25% {filter: drop-shadow(0 0 15px rgba(0, 255, 204, 0.6));}
      50% {filter: drop-shadow(0 0 10px rgba(51, 0, 204, 0.5));}
      75% {filter: drop-shadow(0 0 15px rgba(106, 0, 255, 0.6));}
    }
    .floating-particles {
      position: absolute;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    .particle {
      position: absolute;
      width: 5px; height: 5px;
      border-radius: 50%;
      background: var(--secondary);
      opacity: 0.5;
      animation: float 10s infinite linear;
    }
    @keyframes float {
      0% {transform: translateY(0) translateX(0); opacity: 0;}
      10% {opacity: 0.8;}
      90% {opacity: 0.2;}
      100% {transform: translateY(-100vh) translateX(20px); opacity: 0;}
    }
  </style>
</head>

<body>
  <canvas id="webglCanvas"></canvas>
  <div class="noise-overlay"></div>
  <div class="floating-particles" id="particles"></div>
  
  <div class="container">
    <h1>ORDINARY TECHNOLOGY ACCESS PANEL</h1>
    <h1>BUILDING THE FUTURE</h1>
    <div class="beta">BETA 3.0</div>
    <div class="button-container">
      <button class="button play-button" onclick="navigateToGame()">ENTER DIMENSION</button>
      <button class="button play-button" onclick="navigateToVideoPlayer()">WATCH VIDEOS</button>
      <button class="button play-button" onclick="navigateToLiquidMusic()">LIQUID MUSIC</button>
      <button class="button play-button" onclick="navigateToDimension88()">DIMENSION 88</button>
      <button class="button ai-button" onclick="navigateToAI()">AI INTERFACE</button>
      <button class="button play-button" onclick="navigateToSettings()">UNKNOWN</button>
      <button class="button play-button" onclick="navigateToForum()">ORDINARY WEAPON LAB</button>
      <button class="button play-button" onclick="navigateToStore()">STORE</button>
      <button class="button play-button" onclick="navigateToAbout()">ABOUT</button>
    </div>
  </div>
  
  <div class="console">
    <input type="text" id="consoleInput" placeholder="ENTER COMMAND..." onkeydown="handleConsoleInput(event)" />
  </div>

  <script>
    function navigateToSettings() { window.location.href = 'settings.html'; }
    function navigateToForum() { window.location.href = 'forum.html'; }
    function navigateToStore() { window.location.href = 'store.html'; }
    function navigateToAbout() { window.location.href = 'about.html'; }

    // Preload audio
    const warpSound = new Audio('https://partlydecent.github.io/GAMEHUBORDINARY/warp_sound.mp3');
    warpSound.load();

    // WebGL setup
    const webglCanvas = document.getElementById('webglCanvas');
    webglCanvas.width = window.innerWidth;
    webglCanvas.height = window.innerHeight;
    const gl = webglCanvas.getContext('webgl');

    if (!gl) console.log("WebGL not supported in this browser. Fallback visuals will be used.");

    // Vertex shader source
    const vertexShaderSource = `
      attribute vec4 a_position;
      void main() {
        gl_Position = a_position;
      }
    `;

    // Fragment shader source - Wormhole/Planet morphing grid
    let fragmentShaderSource = `
      precision highp float;
      uniform float u_time;
      
      // Rotation matrix
      mat2 rotate2D(float angle) {
        return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
      }
      
      // Noise function for turbulence
      float noise(vec2 p) {
        return sin(p.x * 10.0) * sin(p.y * 10.0) * 0.5 + 0.5;
      }
      
      void main() {
        vec2 resolution = vec2(800.0, 600.0);
        vec2 uv = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
        uv.x *= resolution.x / resolution.y;
        
        // Time variables for animation
        float t = u_time * 0.2;
        float pulse = sin(t) * 0.5 + 0.5;
        
        // Determine morphing between grid and wormhole/planet
        float morphFactor = sin(t * 0.3) * 0.5 + 0.5;
        
        // Grid effect (base layer)
        vec2 gridUv = uv;
        gridUv *= rotate2D(t * 0.05);
        vec2 grid = abs(fract(gridUv * (5.0 + pulse * 2.0)) - 0.5);
        float gridLine = smoothstep(0.05, 0.06, min(grid.x, grid.y));
        
        // Wormhole/vortex effect
        float dist = length(uv);
        float angle = atan(uv.y, uv.x);
        
        // Spiral pattern for wormhole
        float spiral = fract(angle / 3.14159 * 4.0 + dist * 3.0 - t);
        float spiralLine = smoothstep(0.4, 0.5, spiral) * smoothstep(0.6, 0.5, spiral);
        
        // Planetary/circular grid effect
        float circles = smoothstep(0.03, 0.04, abs(fract(dist * (8.0 + pulse * 4.0)) - 0.5));
        float rays = smoothstep(0.03, 0.04, abs(fract(angle * 8.0 / 3.14159) - 0.5));
        float planet = mix(circles, rays, 0.5);
        
        // Distortion for more organic feel
        float distortion = noise(vec2(angle * 3.0, dist * 5.0 + t)) * 0.1;
        dist += distortion;
        
        // Merging effects based on morphing factor
        float finalPattern = mix(
          gridLine,
          mix(spiralLine, planet, sin(t * 0.5) * 0.5 + 0.5),
          morphFactor
        );
        
        // Create depth effect
        float depth = (1.0 - dist) * (0.5 + 0.5 * sin(t));
        
        // Create color palette
        vec3 blueColor = vec3(0.0, 0.5, 1.0);
        vec3 cyanColor = vec3(0.0, 0.8, 0.8);
        vec3 violetColor = vec3(0.6, 0.0, 0.8);
        
        // Generate dynamic colors based on position and time
        vec3 color = mix(
          mix(violetColor, cyanColor, sin(uv.x + t) * 0.5 + 0.5),
          blueColor,
          sin(length(uv) * 5.0 - t) * 0.5 + 0.5
        );
        
        // Apply pattern with depth effect
        color = mix(color * 0.1, color, finalPattern * (depth * 0.8 + 0.2));
        
        // Add pulse wave emanating from center
        float wave = smoothstep(0.1, 0.0, abs(dist - mod(t * 0.5, 1.0)));
        color += wave * cyanColor * 0.5;
        
        // Add vignette
        float vignette = smoothstep(1.4, 0.3, length(uv));
        color *= vignette;
        
        // Add subtle glow at center for wormhole effect
        color += (1.0 - smoothstep(0.0, 0.5, dist)) * cyanColor * 0.3 * pulse;
        
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // WebGL utility functions
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    // Initialize WebGL shaders
    if (gl) {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      let program = createProgram(gl, vertexShader, fragmentShader);

      // Set up attribute and uniform locations
      let positionAttributeLocation = gl.getAttribLocation(program, "a_position");
      let timeUniformLocation = gl.getUniformLocation(program, "u_time");

      // Create geometry
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, 1, -1, -1, 1, 1, 1, -1];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      // Render loop
      let time = 0;
      function render() {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        gl.uniform1f(timeUniformLocation, time);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        time += 0.01;
        requestAnimationFrame(render);
      }
      render();
      
      // Function to update shader dynamically
      window.updateShader = function(newShaderCode) {
        try {
          const newFragmentShaderSource = `precision highp float; uniform float u_time; void main() { ${newShaderCode} }`;
          const newFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, newFragmentShaderSource);
          if (!newFragmentShader) return;

          const newProgram = createProgram(gl, vertexShader, newFragmentShader);
          if (!newProgram) {
            gl.deleteShader(newFragmentShader);
            return;
          }

          gl.deleteShader(fragmentShader);
          gl.deleteProgram(program);

          fragmentShader = newFragmentShader;
          program = newProgram;

          positionAttributeLocation = gl.getAttribLocation(program, "a_position");
          timeUniformLocation = gl.getUniformLocation(program, "u_time");
        } catch (e) {
          console.error('Shader update error:', e);
        }
      };
    }

    // Create floating particles
    function createParticles() {
      const container = document.getElementById('particles');
      const particleCount = 40; // Increased count
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        
        // Random positions and sizes
        const size = Math.random() * 3 + 1;
        const left = Math.random() * 100;
        const delay = Math.random() * 10;
        const duration = Math.random() * 10 + 10;
        
        // Set CSS properties
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.left = `${left}%`;
        particle.style.bottom = `-5px`;
        particle.style.opacity = Math.random() * 0.5 + 0.1;
        
        // Random colors
        const colors = ['var(--primary)', 'var(--secondary)', 'var(--accent)', '#FFFFFF'];
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        // Animation properties
        particle.style.animation = `float ${duration}s infinite linear`;
        particle.style.animationDelay = `${delay}s`;
        
        container.appendChild(particle);
      }
    }
    createParticles();

    // Navigation functions
    function navigateToGame() {
      animateButtonAndNavigate('.play-button', 'https://partlydecent.github.io/GAMEHUBORDINARY/game.html');
    }
    function navigateToVideoPlayer() {
      animateButtonAndNavigate(document.querySelectorAll('.play-button')[1], 'https://partlydecent.github.io/GAMEHUBORDINARY/videoPlayer.html');
    }
    function navigateToLiquidMusic() {
      animateButtonAndNavigate(document.querySelectorAll('.play-button')[2], 'https://partlydecent.github.io/GAMEHUBORDINARY/liquidMusic.html');
    }
    function navigateToDimension88() {
      animateButtonAndNavigate(document.querySelectorAll('.play-button')[3], 'https://partlydecent.github.io/GAMEHUBORDINARY/dimension88.html');
    }
    function navigateToAI() {
      animateButtonAndNavigate('.ai-button', 'https://partlydecent.github.io/GAMEHUBORDINARY/ai.html');
    }

    function animateButtonAndNavigate(selector, url) {
      try {
        const button = typeof selector === 'string' ? document.querySelector(selector) : selector;
        const warp = document.createElement('div');
        warp.classList.add('warp-distortion');
        document.body.appendChild(warp);

        try {
          warpSound.currentTime = 0;
          warpSound.play().catch(e => console.log('Audio play failed:', e));
        } catch (e) {
          console.log('Audio error:', e);
        }

        button.style.transform = 'scale(0.9)';
        setTimeout(() => {
          button.style.transform = 'scale(1)';
          setTimeout(() => {
            window.location.href = url;
          }, 500);
        }, 100);
      } catch (e) {
        console.error('Navigation error:', e);
        window.location.href = url;
      }
    }

    // Console input handling
    function handleConsoleInput(event) {
      if (event.key === 'Enter') {
        const input = event.target.value.toLowerCase();
        const easterEggs = {
          'ali3n': 'easteregg.html', 'zombie1': 'egg1.html', 'valve2': 'egg2.html',
          'unr3al': 'egg3.html', 'phant0m': 'egg4.html', 'shadow5': 'egg5.html',
          'glitchx': 'egg6.html', 'oblivion7': 'egg7.html', 'cyb3rpunk': 'egg8.html',
          'n3on9': 'egg9.html', 'matrix10': 'egg10.html', 'quantum11': 'egg11.html',
          'nebula12': 'egg12.html', 'vortex13': 'egg13.html', 'enigma14': 'egg14.html',
          'paradox15': 'egg15.html', 'synapse16': 'egg16.html', 'zenith17': 'egg17.html',
          'wormhole3': 'wormhole.html', 'pulse': 'pulse.html', 'stargate': 'stargate.html
		  'wormhole3': 'wormhole.html', 'pulse': 'pulse.html', 'stargate': 'stargate.html',
          'cosmic': 'cosmic.html', 'void': 'void.html', 'labyrinth': 'labyrinth.html'
        };
        
        if (easterEggs[input]) {
          event.target.value = 'ACCESSING ' + input.toUpperCase() + '...';
          setTimeout(() => {
            animateWarpAndNavigate(easterEggs[input]);
          }, 1000);
        } else if (input === 'help') {
          alert('Available commands: help, reset, fullscreen, dark, light, version');
        } else if (input === 'reset') {
          window.location.reload();
        } else if (input === 'fullscreen') {
          document.documentElement.requestFullscreen();
        } else if (input === 'dark') {
          document.body.style.setProperty('--background', '#050511');
        } else if (input === 'light') {
          document.body.style.setProperty('--background', '#1a1a2e');
        } else if (input === 'version') {
          alert('ORDINARY TECHNOLOGY ACCESS PANEL - Version BETA 3.0\nBuild Date: March 2025');
        } else {
          event.target.value = 'UNKNOWN COMMAND: ' + input;
          setTimeout(() => {
            event.target.value = '';
          }, 1500);
        }
      }
    }

    function animateWarpAndNavigate(url) {
      const warp = document.createElement('div');
      warp.classList.add('warp-distortion');
      document.body.appendChild(warp);
      
      try {
        warpSound.currentTime = 0;
        warpSound.play().catch(e => console.log('Audio play failed:', e));
      } catch (e) {
        console.log('Audio error:', e);
      }
      
      setTimeout(() => {
        window.location.href = url;
      }, 1000);
    }

    // Window resize handler
    window.addEventListener('resize', () => {
      if (gl) {
        webglCanvas.width = window.innerWidth;
        webglCanvas.height = window.innerHeight;
        gl.viewport(0, 0, webglCanvas.width, webglCanvas.height);
      }
    });

    // Initial focus on console input
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        document.getElementById('consoleInput').focus();
      }, 1000);
    });

    // Easter egg key combo detection
    let keySequence = '';
    document.addEventListener('keydown', (e) => {
      keySequence += e.key.toLowerCase();
      keySequence = keySequence.slice(-10);
      
      const secretCombos = {
        'arrowuparrowuparrowdownarrowdownarrowleftarrowrightarrowleftarrowright': 'konami.html',
        'xyzzy': 'adventure.html',
        'idkfa': 'doom.html'
      };
      
      Object.keys(secretCombos).forEach(combo => {
        if (keySequence.includes(combo)) {
          animateWarpAndNavigate(secretCombos[combo]);
        }
      });
    });
  </script>
</body>
</html>
