<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neuromantic Player</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
    
    :root {
      --primary: #ff4b00;
      --secondary: #00ffd0;
      --bg-dark: #0a0b0c;
      --bg-light: #121416;
      --text: #e0e0e0;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background-color: var(--bg-dark);
      color: var(--text);
      font-family: 'Space Mono', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow-x: hidden;
    }
    
    #background-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    header {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 2rem;
      position: relative;
      text-transform: uppercase;
      color: var(--primary);
    }
    
    header::after {
      content: 'PLAYER';
      position: absolute;
      left: 0;
      top: 0;
      color: var(--secondary);
      clip-path: polygon(0 0, 100% 0, 100% 50%, 0 50%);
    }
    
    .player-container {
      width: 90%;
      max-width: 800px;
      background: var(--bg-light);
      border-radius: 2px;
      position: relative;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    .player-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }
    
    .track-info {
      display: grid;
      grid-template-columns: 1fr auto;
      padding: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .track-title {
      font-weight: bold;
      color: var(--primary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .track-number { color: var(--secondary); }
    
    .progress-container {
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      cursor: pointer;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      width: 0%;
    }
    
    .time-display {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 1rem;
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      padding: 0.5rem 1rem;
    }
    
    .controls button {
      background: none;
      border: none;
      color: var(--text);
      font-family: inherit;
      padding: 0.5rem;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: bold;
    }
    
    .controls button:hover { color: var(--primary); }
    
    canvas {
      width: 100%;
      height: 200px;
      display: block;
    }
    
    .visualizer-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 200px;
      pointer-events: none;
    }
    
    .visualizer-controls {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      background: rgba(0, 0, 0, 0.2);
    }
    
    .visualizer-controls button {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      font-family: inherit;
      font-size: 0.6rem;
      padding: 0.25rem;
      cursor: pointer;
      text-transform: uppercase;
    }
    
    .visualizer-controls button.active { color: var(--secondary); }
    
    .playlist-toggle {
      width: 100%;
      background: none;
      border: none;
      padding: 0.75rem;
      color: var(--text);
      font-family: inherit;
      cursor: pointer;
      text-transform: uppercase;
    }
    
    .playlist-container {
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.2);
    }
    
    .playlist-item {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 1rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .playlist-item:hover { background: rgba(255, 255, 255, 0.05); }
    .playlist-item.active { background: rgba(255, 75, 0, 0.1); }
    .playlist-item.active span:last-child { color: var(--primary); }
  </style>
</head>
<body>
  <canvas id="background-canvas"></canvas>
  
  <header>Neuromantic</header>
  <div class="player-container">
    <div class="visualizer-container">
      <canvas id="visualizer"></canvas>
    </div>
  
    <audio id="musicPlayer" src="track1.mp3"></audio>
    <div class="track-info">
      <div class="track-title" id="trackTitle">Liquid Dreams</div>
      <div class="track-number"><span id="currentTrackNum">1</span>/20</div>
    </div>
    <div class="progress-container" id="progressContainer">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="time-display">
      <span id="currentTime">0:00</span>
      <span id="totalTime">0:00</span>
    </div>
    <div class="controls">
      <button id="prevTrack">Prev</button>
      <button id="playPause">Play</button>
      <button id="nextTrack">Next</button>
    </div>
    
    <div class="visualizer-controls">
      <button id="viz1" class="active">Bars</button>
      <button id="viz2">Circles</button>
      <button id="viz3">Wave</button>
      <button id="viz4">Stars</button>
      <button id="viz5">Spectrum</button>
    </div>
    <button class="playlist-toggle" id="playlistToggle">Playlist</button>
    <div class="playlist-container" id="playlist" style="display:none;"></div>
  </div>
  <script>
    // DOM elements
    const $ = id => document.getElementById(id);
    const musicPlayer = $('musicPlayer');
    const playPauseBtn = $('playPause');
    const canvas = $('visualizer');
    const ctx = canvas.getContext('2d');
    const progressBar = $('progressBar');
    const progressContainer = $('progressContainer');
    
    // 3D Neural Network Brain Visualization
const bgCanvas = document.getElementById('background-canvas');
const renderer = new THREE.WebGLRenderer({ canvas: bgCanvas, alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 180;

// Lighting
const ambientLight = new THREE.AmbientLight(0x222222);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(0, 0, 50);
scene.add(pointLight);

// Track list
const tracks = [
  { src: 'track1.wav', title: 'Liquid Dreams' },
  { src: 'track2.wav', title: 'Neon Flow' },
  { src: 'track3.wav', title: 'Cosmic Wave' },
  { src: 'track4.wav', title: 'Digital Sunrise' },
  { src: 'track5.wav', title: 'Quantum Beat' },
  { src: 'track6.wav', title: 'Cyberspace Odyssey' },
  { src: 'track7.wav', title: 'Neural Network' },
  { src: 'track8.wav', title: 'Binary Echoes' },
  { src: 'track9.wav', title: 'Virtual Reality' },
  { src: 'track10.wav', title: 'Holographic Memory' },
  { src: 'track11.wav', title: 'Singularity' },
  { src: 'track12.wav', title: 'Electric Dreams' },
  { src: 'track13.wav', title: 'Synthwave Journey' },
  { src: 'track14.wav', title: 'Galactic Pulse' },
  { src: 'track15.wav', title: 'Cyber Dawn' },
  { src: 'track16.wav', title: 'Ethereal Code' },
  { src: 'track17.mp3', title: 'Alternatives' },
  { src: 'track18.wav', title: 'Astral Projection' },
  { src: 'track19.wav', title: 'Plasma Field' },
  { src: 'track20.wav', title: 'Quantum Resonance' }
];

// State variables
let currentTrackIndex = 0;
let currentVisualizer = 1;
let animationId = null;
let audioContext, analyser, source, dataArray, bufferLength;

// Advanced 3D brain network state
const brainNetwork = new THREE.Group();
scene.add(brainNetwork);

const neurons = [];
const connections = [];
const neuronCount = 350; // More neurons for complexity
const colorSchemes = [
  { neuron: 0xff4b00, connection: 0x00ffd0, secondary: 0x001f33 },
  { neuron: 0x00ffd0, connection: 0xff4b00, secondary: 0x330019 },
  { neuron: 0xff00ff, connection: 0x00ffff, secondary: 0x002233 },
  { neuron: 0xffff00, connection: 0x0088ff, secondary: 0x220033 }
];
let currentColorScheme = 0;
let reactivityFactor = 0;
let rotationSpeed = 0.003;

// Helper functions
const formatTime = s => `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;

// Audio context initialization
function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    source = audioContext.createMediaElementSource(musicPlayer);
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    analyser.fftSize = 1024; // Higher resolution for better analysis
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
  }
}

// Create a brain-like neural network shape
function initNeuralNetwork() {
  // Clear previous network
  while(brainNetwork.children.length > 0) {
    brainNetwork.remove(brainNetwork.children[0]);
  }
  neurons.length = 0;
  connections.length = 0;
  
  // Create neuron material
  const colors = colorSchemes[currentColorScheme];
  const neuronMaterial = new THREE.MeshPhongMaterial({
    color: colors.neuron,
    emissive: colors.neuron,
    emissiveIntensity: 0.3,
    specular: 0xffffff,
    shininess: 100
  });
  
  const neuronGeometry = new THREE.SphereGeometry(1, 16, 16);
  
  // Create neurons in a brain-like arrangement
  for (let i = 0; i < neuronCount; i++) {
    // Create brain-shaped distribution using parametric equations
    const t = Math.random() * Math.PI * 2;
    const u = Math.random() * Math.PI;
    const v = Math.random() * 2 - 1;
    
    // Brain shape parameters
    const a = 50, b = 30, c = 40;
    
    // Ellipsoid with perturbations to make it brain-like
    let x = a * Math.sin(u) * Math.cos(t);
    let y = b * Math.sin(u) * Math.sin(t);
    let z = c * Math.cos(u);
    
    // Add some cerebral cortex-like folding
    const fold = 5 * Math.sin(5 * u) * Math.sin(4 * t);
    const rFactor = 1 + 0.2 * Math.sin(8 * t) * Math.sin(6 * u);
    
    x *= rFactor;
    y *= rFactor;
    z *= rFactor + fold * 0.05;
    
    // Create hemispheres with a dividing line
    if (Math.random() > 0.5) {
      x = Math.abs(x) * 0.9; // Right hemisphere
    } else {
      x = -Math.abs(x) * 0.9; // Left hemisphere
    }
    
    // Create the neuron
    const neuron = new THREE.Mesh(neuronGeometry, neuronMaterial.clone());
    neuron.position.set(x, y, z);
    
    // Size variation
    const size = Math.random() * 0.8 + 0.6;
    neuron.scale.set(size, size, size);
    
    // Add to our collections
    brainNetwork.add(neuron);
    neurons.push({
      mesh: neuron,
      originalSize: size,
      pulseSpeed: Math.random() * 0.04 + 0.01,
      pulsePhase: Math.random() * Math.PI * 2,
      originalPos: new THREE.Vector3(x, y, z)
    });
  }
  
  // Create connections between nearby neurons
  const connectionMaterial = new THREE.LineBasicMaterial({
    color: colors.connection,
    transparent: true,
    opacity: 0.4,
    linewidth: 1
  });
  
  // Create axon-like connections, more for nearby neurons
  for (let i = 0; i < neurons.length; i++) {
    const neuronA = neurons[i];
    
    // Connect to nearby neurons (up to 5 connections per neuron)
    const potentialConnections = [];
    
    for (let j = 0; j < neurons.length; j++) {
      if (i !== j) {
        const neuronB = neurons[j];
        const distance = neuronA.mesh.position.distanceTo(neuronB.mesh.position);
        
        // Only connect to relatively close neurons
        if (distance < 30) {
          potentialConnections.push({
            neuron: neuronB,
            distance: distance
          });
        }
      }
    }
    
    // Sort by distance and take the closest few
    potentialConnections.sort((a, b) => a.distance - b.distance);
    const connectCount = Math.min(3, potentialConnections.length);
    
    for (let c = 0; c < connectCount; c++) {
      const geometry = new THREE.BufferGeometry();
      const points = [
        neuronA.mesh.position.clone(),
        potentialConnections[c].neuron.mesh.position.clone()
      ];
      geometry.setFromPoints(points);
      
      const line = new THREE.Line(geometry, connectionMaterial.clone());
      line.userData = {
        from: neuronA,
        to: potentialConnections[c].neuron,
        originalOpacity: 0.2 + Math.random() * 0.3,
        pulsePhase: Math.random() * Math.PI * 2,
        pulseSpeed: Math.random() * 0.05 + 0.02
      };
      
      brainNetwork.add(line);
      connections.push(line);
    }
  }
  
  // Add some lobes/hemispheric definition with grouped neuron clusters
  addBrainLobe(30, 10, 10, 15, 12, 8); // Frontal lobe
  addBrainLobe(-30, 10, 10, 15, 12, 8); // Other frontal lobe
  addBrainLobe(25, -20, 5, 12, 10, 6);  // Temporal lobe
  addBrainLobe(-25, -20, 5, 12, 10, 6); // Other temporal lobe
  addBrainLobe(0, -25, 20, 15, 10, 10); // Occipital lobe
  
  // Add cerebellum-like structure
  addBrainLobe(0, -15, -25, 20, 8, 10, true);
}

// Create a cluster of neurons to form brain lobes
function addBrainLobe(x, y, z, radius, count, connectionCount, isCerebellum = false) {
  const colors = colorSchemes[currentColorScheme];
  const lobeNeurons = [];
  const neuronGeometry = new THREE.SphereGeometry(1, 16, 16);
  
  // Material with lobe-specific color variation
  const neuronMaterial = new THREE.MeshPhongMaterial({
    color: colors.neuron,
    emissive: colors.neuron,
    emissiveIntensity: 0.3,
    specular: 0xffffff,
    shininess: 100
  });
  
  // Create neurons for this lobe
  for (let i = 0; i < count; i++) {
    // Position within the lobe
    let nx, ny, nz;
    
    if (isCerebellum) {
      // Create folded pattern for cerebellum
      const t = Math.random() * Math.PI * 2;
      const r = radius * Math.random();
      nx = x + r * Math.cos(t);
      ny = y + r * Math.sin(t) * 0.5;
      nz = z + Math.sin(t * 8) * 3; // Folded pattern
    } else {
      // Random position within lobe sphere
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const r = radius * Math.pow(Math.random(), 0.3); // Concentrate toward center
      
      nx = x + r * Math.sin(phi) * Math.cos(theta);
      ny = y + r * Math.sin(phi) * Math.sin(theta);
      nz = z + r * Math.cos(phi);
    }
    
    // Create the neuron
    const neuron = new THREE.Mesh(neuronGeometry, neuronMaterial.clone());
    neuron.position.set(nx, ny, nz);
    
    // Size variation
    const size = Math.random() * 0.7 + 0.5;
    neuron.scale.set(size, size, size);
    
    // Add to our collections
    brainNetwork.add(neuron);
    const neuronData = {
      mesh: neuron,
      originalSize: size,
      pulseSpeed: Math.random() * 0.04 + 0.01,
      pulsePhase: Math.random() * Math.PI * 2,
      originalPos: new THREE.Vector3(nx, ny, nz),
      isLobe: true
    };
    
    neurons.push(neuronData);
    lobeNeurons.push(neuronData);
  }
  
  // Create more dense connections within the lobe
  const connectionMaterial = new THREE.LineBasicMaterial({
    color: colors.connection,
    transparent: true,
    opacity: 0.5
  });
  
  // Connect neurons within this lobe
  for (let i = 0; i < lobeNeurons.length; i++) {
    const neuronA = lobeNeurons[i];
    
    // Number of connections for this neuron
    const connectCount = Math.floor(Math.random() * connectionCount) + 1;
    
    for (let c = 0; c < connectCount; c++) {
      // Pick another random neuron in this lobe
      const j = Math.floor(Math.random() * lobeNeurons.length);
      if (i !== j) {
        const neuronB = lobeNeurons[j];
        
        const geometry = new THREE.BufferGeometry();
        const points = [
          neuronA.mesh.position.clone(),
          neuronB.mesh.position.clone()
        ];
        geometry.setFromPoints(points);
        
        const line = new THREE.Line(geometry, connectionMaterial.clone());
        line.userData = {
          from: neuronA,
          to: neuronB,
          originalOpacity: 0.3 + Math.random() * 0.4,
          pulsePhase: Math.random() * Math.PI * 2,
          pulseSpeed: Math.random() * 0.08 + 0.04,
          isLobe: true
        };
        
        brainNetwork.add(line);
        connections.push(line);
      }
    }
  }
}

// Main render function
function renderNeuralNetwork() {
  if (!audioContext) {
    animationId = requestAnimationFrame(renderNeuralNetwork);
    return;
  }
  
  animationId = requestAnimationFrame(renderNeuralNetwork);
  analyser.getByteFrequencyData(dataArray);
  
  // Calculate overall audio reactivity using frequency bands
  let bassSum = 0;
  let midSum = 0;
  let trebleSum = 0;
  
  // Different frequency bands
  for (let i = 0; i < bufferLength; i++) {
    if (i < bufferLength * 0.1) {
      bassSum += dataArray[i]; // Bass frequencies
    } else if (i < bufferLength * 0.5) {
      midSum += dataArray[i];  // Mid frequencies
    } else {
      trebleSum += dataArray[i]; // Treble frequencies
    }
  }
  
  const bassReactivity = bassSum / (bufferLength * 0.1 * 255);
  const midReactivity = midSum / (bufferLength * 0.4 * 255);
  const trebleReactivity = trebleSum / (bufferLength * 0.5 * 255);
  reactivityFactor = (bassReactivity + midReactivity + trebleReactivity) / 3;
  
  // Adjust brain rotation based on bass
  rotationSpeed = 0.002 + bassReactivity * 0.005;
  brainNetwork.rotation.y += rotationSpeed;
  brainNetwork.rotation.x = Math.sin(Date.now() * 0.0003) * 0.2;
  
  // Update neurons based on audio
  neurons.forEach((neuron, i) => {
    const time = Date.now() * 0.001;
    const freqIndex = Math.floor(i / neurons.length * bufferLength);
    const freqValue = dataArray[freqIndex] / 255;
    
    // Neuron pulse based on audio and its own rhythm
    const pulse = 0.2 * freqValue * reactivityFactor + 
                 0.1 * Math.sin(time * neuron.pulseSpeed + neuron.pulsePhase);
    
    // Scale the neuron with pulse
    const scale = neuron.originalSize * (1 + pulse);
    neuron.mesh.scale.set(scale, scale, scale);
    
    // Neurons can move slightly based on audio
    if (reactivityFactor > 0.4) {
      const moveAmount = 0.1 * reactivityFactor;
      neuron.mesh.position.x = neuron.originalPos.x + (Math.random() - 0.5) * moveAmount;
      neuron.mesh.position.y = neuron.originalPos.y + (Math.random() - 0.5) * moveAmount;
      neuron.mesh.position.z = neuron.originalPos.z + (Math.random() - 0.5) * moveAmount;
    }
    
    // Color reactivity
    const colors = colorSchemes[currentColorScheme];
    const material = neuron.mesh.material;
    
    // Blend color based on audio intensity
    const r = ((colors.neuron >> 16) & 0xff) / 255;
    const g = ((colors.neuron >> 8) & 0xff) / 255;
    const b = (colors.neuron & 0xff) / 255;
    
    const sr = ((colors.secondary >> 16) & 0xff) / 255;
    const sg = ((colors.secondary >> 8) & 0xff) / 255;
    const sb = (colors.secondary & 0xff) / 255;
    
    // Blend between primary and secondary color based on audio
    const blendFactor = Math.min(1, freqValue * 2);
    material.color.setRGB(
      r * (1 - blendFactor) + sr * blendFactor,
      g * (1 - blendFactor) + sg * blendFactor,
      b * (1 - blendFactor) + sb * blendFactor
    );
    
    // Emissive intensity based on audio
    material.emissiveIntensity = 0.2 + freqValue * 0.8;
  });
  
  // Update connections
  connections.forEach((connection, i) => {
    // Update the line position to follow the neurons
    const geometry = connection.geometry;
    const positions = geometry.attributes.position.array;
    
    positions[0] = connection.userData.from.mesh.position.x;
    positions[1] = connection.userData.from.mesh.position.y;
    positions[2] = connection.userData.from.mesh.position.z;
    
    positions[3] = connection.userData.to.mesh.position.x;
    positions[4] = connection.userData.to.mesh.position.y;
    positions[5] = connection.userData.to.mesh.position.z;
    
    geometry.attributes.position.needsUpdate = true;
    
    // Neuron firing effect along the connection
    const time = Date.now() * 0.001;
    const freqIndex = Math.floor(i / connections.length * bufferLength);
    const freqValue = dataArray[freqIndex] / 255;
    
    const pulseValue = Math.sin(time * connection.userData.pulseSpeed + connection.userData.pulsePhase);
    const signalIntensity = (0.5 + 0.5 * pulseValue) * freqValue * 0.8 + 0.2;
    
    // Connection color and opacity based on audio
    const colors = colorSchemes[currentColorScheme];
    connection.material.opacity = connection.userData.originalOpacity * (0.2 + 0.8 * signalIntensity);
    
    // Make connections glow in reaction to strong audio signals
    if (freqValue > 0.7) {
      connection.material.color.setHex(colors.neuron); // Temporary color change for pulse effect
    } else {
      connection.material.color.setHex(colors.connection);
    }
  });
  
  // Occasionally change color scheme based on music intensity
  if (Math.random() < 0.0005 + reactivityFactor * 0.001) {
    currentColorScheme = (currentColorScheme + 1) % colorSchemes.length;
    updateNetworkColors();
  }
  
  renderer.render(scene, camera);
}

// Update all materials when color scheme changes
function updateNetworkColors() {
  const colors = colorSchemes[currentColorScheme];
  
  // Update all neuron colors
  neurons.forEach(neuron => {
    neuron.mesh.material.color.setHex(colors.neuron);
    neuron.mesh.material.emissive.setHex(colors.neuron);
  });
  
  // Update all connection colors
  connections.forEach(connection => {
    connection.material.color.setHex(colors.connection);
  });
}

// Window resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Initialize neural network and start rendering
initNeuralNetwork();
renderNeuralNetwork();

// Apply post-processing for advanced visual effects
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

// Bloom effect for glowing neurons
const bloomPass = new THREE.UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.0,   // strength
  0.4,   // radius
  0.85   // threshold
);
composer.addPass(bloomPass);

// Replace the simple render function with the composer version
function renderWithEffects() {
  if (!audioContext) {
    animationId = requestAnimationFrame(renderWithEffects);
    return;
  }
  
  animationId = requestAnimationFrame(renderWithEffects);
  analyser.getByteFrequencyData(dataArray);
  
  // All the neuron and connection updates from renderNeuralNetwork
  // ... (code from renderNeuralNetwork)
  
  composer.render();
}

// Use the enhanced render function instead
cancelAnimationFrame(animationId);
renderWithEffects();

    // Track management
    function loadTrack(index) {
      index = (index + tracks.length) % tracks.length;
      currentTrackIndex = index;
      musicPlayer.src = tracks[index].src;
      $('trackTitle').textContent = tracks[index].title;
      $('currentTrackNum').textContent = index + 1;
      
      document.querySelectorAll('.playlist-item').forEach(item => {
        item.classList.toggle('active', item.dataset.index == index);
      });
      
      const activeItem = document.querySelector(`.playlist-item[data-index="${index}"]`);
      if (activeItem) activeItem.scrollIntoView({behavior: 'smooth', block: 'nearest'});
      
      musicPlayer.load();
    }

    function createPlaylist() {
      const playlist = $('playlist');
      playlist.innerHTML = '';
      
      tracks.forEach((track, i) => {
        const item = document.createElement('div');
        item.className = 'playlist-item' + (i === currentTrackIndex ? ' active' : '');
        item.dataset.index = i;
        
        item.innerHTML = `
          <span>${(i + 1).toString().padStart(2, '0')}</span>
          <span>${track.title}</span>
        `;
        
        item.addEventListener('click', () => {
          loadTrack(i);
          playTrack();
        });
        
        playlist.appendChild(item);
      });
    }

    // Playback controls
    function playTrack() {
      initAudio();
      audioContext.resume().then(() => {
        musicPlayer.play();
        playPauseBtn.textContent = 'Pause';
        if (!animationId) renderVisualizer();
      });
    }

    function pauseTrack() {
      musicPlayer.pause();
      playPauseBtn.textContent = 'Play';
    }

    // Progress bar update
    function updateProgress() {
      if (!musicPlayer.duration) return;
      
      progressBar.style.width = `${(musicPlayer.currentTime / musicPlayer.duration) * 100}%`;
      $('currentTime').textContent = formatTime(musicPlayer.currentTime);
      $('totalTime').textContent = formatTime(musicPlayer.duration);
    }

    // Visualizer rendering functions
    function renderVisualizer() {
      if (!audioContext) return;
      animationId = requestAnimationFrame(renderVisualizer);
      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const vizFuncs = [
        drawHolographicBars,
        drawQuantumCircles,
        drawNeuralWave,
        drawGalacticStars,
        draw4DSpectrum
      ];
      
      vizFuncs[currentVisualizer - 1]();
    }

  function drawHolographicBars() {
  const barWidth = (canvas.width / bufferLength) * 2.5;
  
  // Create a time-based shimmer effect
  const time = Date.now() * 0.001;
  
  for (let i = 0, x = 0; i < bufferLength; i++, x += barWidth + 1) {
    const barHeight = dataArray[i];
    
    // Add a pulsing effect based on audio data and time
    const pulseIntensity = 0.2 * Math.sin(time + i * 0.1) + 1;
    const adjustedHeight = barHeight * pulseIntensity;
    
    // Create a more vibrant holographic gradient
    const gradient = ctx.createLinearGradient(x, canvas.height, x, canvas.height - adjustedHeight);
    
    // Dynamic color based on frequency and time
    const hue1 = (barHeight + time * 20) % 360;
    const hue2 = (hue1 + 180) % 360;
    
    gradient.addColorStop(0, `hsla(${hue1}, 100%, 70%, 0.9)`);
    gradient.addColorStop(0.5, `hsla(${(hue1 + 60) % 360}, 100%, 60%, 0.7)`);
    gradient.addColorStop(1, `hsla(${hue2}, 100%, 80%, 0.3)`);
    
    ctx.fillStyle = gradient;
    
    // Draw bar with rounded top
    ctx.beginPath();
    ctx.moveTo(x, canvas.height);
    ctx.lineTo(x, canvas.height - adjustedHeight / 2);
    ctx.arc(x + barWidth / 2, canvas.height - adjustedHeight / 2, barWidth / 2, Math.PI, 0, false);
    ctx.lineTo(x + barWidth, canvas.height);
    ctx.closePath();
    ctx.fill();
    
    // Add holographic glow effect
    ctx.shadowColor = `hsla(${hue1}, 100%, 70%, 0.7)`;
    ctx.shadowBlur = 15 * (barHeight / 255);
    
    // Add shimmering stroke
    const strokeOpacity = 0.3 + 0.5 * Math.sin(time * 3 + i * 0.2);
    ctx.strokeStyle = `rgba(255, 255, 255, ${strokeOpacity})`;
    ctx.lineWidth = 0.5 + (barHeight / 255) * 1.5;
    ctx.stroke();
    
    // Reset shadow for next iteration
    ctx.shadowBlur = 0;
    
    // Add occasional vertical light streak for extra dimension
    if (Math.random() < 0.05) {
      ctx.beginPath();
      const streakX = x + barWidth * Math.random();
      ctx.strokeStyle = `rgba(255, 255, 255, 0.7)`;
      ctx.lineWidth = 0.5;
      ctx.moveTo(streakX, canvas.height);
      ctx.lineTo(streakX, canvas.height - adjustedHeight * 1.2);
      ctx.stroke();
    }
  }
}
   function drawQuantumCircles() {
  // Use performance time to drive dynamic animations
  const t = performance.now() / 1000;
  for (let i = 0; i < bufferLength; i++) {
    // Base angle with a slight time-based offset for subtle motion
    const angle = (Math.PI * 2 * i / bufferLength) + (Math.sin(t + i) * 0.05);
    // Base radius scaled from audio data with an additional pulsating factor
    const baseRadius = dataArray[i] / 255 * Math.min(canvas.width, canvas.height) / 4;
    const pulsate = 1 + 0.2 * Math.sin(t * 3 + i);
    const radius = baseRadius * pulsate;
    // Calculate circle center positions around the canvas center
    const x = canvas.width / 2 + Math.cos(angle) * radius;
    const y = canvas.height / 2 + Math.sin(angle) * radius;
    
    // Create an enhanced radial gradient with three stops for smooth color transitions
    const hue = (i * 360 / bufferLength + t * 40) % 360;
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius / 5);
    gradient.addColorStop(0, `hsla(${hue}, 100%, 60%, 1)`);
    gradient.addColorStop(0.7, `hsla(${(hue + 30) % 360}, 100%, 55%, 0.7)`);
    gradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 50%, 0)`);

    // Draw the primary circle with the custom gradient
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius / 5, 0, Math.PI * 2);
    ctx.fill();

    // Use a sine-based modulation for stroke opacity for smooth, rhythmic transitions
    const strokeOpacity = (Math.sin(t + i / 10) * 0.5 + 0.5).toFixed(2);
    ctx.strokeStyle = `rgba(255, 255, 255, ${strokeOpacity})`;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(canvas.width / 2, canvas.height / 2);
    ctx.stroke();

    // Add a secondary, larger arc for that extra uncanny glow effect
    ctx.beginPath();
    ctx.arc(x, y, radius / 4, 0, Math.PI * 2);
    ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${strokeOpacity})`;
    ctx.stroke();
  }
}


    function drawNeuralWave() {
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();

      const sliceWidth = canvas.width / bufferLength;
      
      for (let i = 0, x = 0; i < bufferLength; i++, x += sliceWidth) {
        const v = dataArray[i] / 128.0;
        const y = v * canvas.height / 2;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);

        ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, 255, 0.8)`;
        ctx.beginPath();
        ctx.arc(x, y, v * 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();
    }

    function drawGalacticStars() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'lighter';
      
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const dataIndex = Math.floor((i / 100) * bufferLength);
        const radius = (dataArray[dataIndex] / 255) * 3 + 1;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${dataArray[dataIndex]/255})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
      
      ctx.globalCompositeOperation = 'source-over';
    }

    function draw4DSpectrum() {
      const barWidth = canvas.width / bufferLength;
      
      for (let i = 0; i < bufferLength; i++) {
        const barHeight = dataArray[i];
        const x = i * barWidth;
        const hue = i / bufferLength * 360;

        const gradient = ctx.createLinearGradient(x, canvas.height, x, canvas.height - barHeight);
        gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 1)`);
        gradient.addColorStop(1, `hsla(${hue}, 100%, 80%, 0.2)`);

        ctx.fillStyle = gradient;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

        ctx.globalAlpha = Math.sin(Date.now() / 1000 + i / bufferLength * Math.PI * 2) * 0.5 + 0.5;
        ctx.fillStyle = `hsla(${(hue + 180) % 360}, 100%, 50%, 0.5)`;
        ctx.fillRect(x, canvas.height - barHeight * 0.5, barWidth, barHeight * 0.5);
        ctx.globalAlpha = 1;
      }
    }

    // Event Handlers
    function updateVisualizerButtons() {
      document.querySelectorAll('.visualizer-controls button').forEach((btn, i) => {
        btn.classList.toggle('active', i + 1 === currentVisualizer);
      });
    }

    // Event listeners
    playPauseBtn.addEventListener('click', () => musicPlayer.paused ? playTrack() : pauseTrack());
    $('prevTrack').addEventListener('click', () => { loadTrack(currentTrackIndex - 1); playTrack(); });
    $('nextTrack').addEventListener('click', () => { loadTrack(currentTrackIndex + 1); playTrack(); });
    musicPlayer.addEventListener('ended', () => { loadTrack(currentTrackIndex + 1); playTrack(); });
    musicPlayer.addEventListener('timeupdate', updateProgress);
    musicPlayer.addEventListener('durationchange', () => { $('totalTime').textContent = formatTime(musicPlayer.duration); });
    
    progressContainer.addEventListener('click', e => {
      musicPlayer.currentTime = (e.offsetX / progressContainer.offsetWidth) * musicPlayer.duration;
    });
    
    $('playlistToggle').addEventListener('click', () => {
      const playlist = $('playlist');
      const isHidden = playlist.style.display === 'none';
      playlist.style.display = isHidden ? 'block' : 'none';
      $('playlistToggle').textContent = isHidden ? 'Hide Playlist' : 'Playlist';
    });

    // Visualizer controls
    document.querySelectorAll('.visualizer-controls button').forEach((btn, i) => {
      btn.addEventListener('click', () => {
        currentVisualizer = i + 1;
        updateVisualizerButtons();
      });
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      initNeuralNetwork();
    });

    // Initialize
    loadTrack(currentTrackIndex);
    createPlaylist();
    initNeuralNetwork();
    renderNeuralBackground();
  </script>
</body>
</html>
