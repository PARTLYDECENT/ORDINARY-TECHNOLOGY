<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neuromantic Player</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
    
    :root {
      --primary: #ff4b00;
      --secondary: #00ffd0;
      --bg-dark: #0a0b0c;
      --bg-light: #121416;
      --text: #e0e0e0;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background-color: var(--bg-dark);
      color: var(--text);
      font-family: 'Space Mono', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow-x: hidden;
    }
    
    #background-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    header {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 2rem;
      position: relative;
      text-transform: uppercase;
      color: var(--primary);
    }
    
    header::after {
      content: 'PLAYER';
      position: absolute;
      left: 0;
      top: 0;
      color: var(--secondary);
      clip-path: polygon(0 0, 100% 0, 100% 50%, 0 50%);
    }
    
    .player-container {
      width: 90%;
      max-width: 800px;
      background: var(--bg-light);
      border-radius: 2px;
      position: relative;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    .player-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }
    
    .track-info {
      display: grid;
      grid-template-columns: 1fr auto;
      padding: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .track-title {
      font-weight: bold;
      color: var(--primary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .track-number { color: var(--secondary); }
    
    .progress-container {
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      cursor: pointer;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      width: 0%;
    }
    
    .time-display {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 1rem;
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.5);
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      padding: 0.5rem 1rem;
    }
    
    .controls button {
      background: none;
      border: none;
      color: var(--text);
      font-family: inherit;
      padding: 0.5rem;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: bold;
    }
    
    .controls button:hover { color: var(--primary); }
    
    canvas {
      width: 100%;
      height: 200px;
      display: block;
    }
    
    .visualizer-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 200px;
      pointer-events: none;
    }
    
    .visualizer-controls {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      background: rgba(0, 0, 0, 0.2);
    }
    
    .visualizer-controls button {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      font-family: inherit;
      font-size: 0.6rem;
      padding: 0.25rem;
      cursor: pointer;
      text-transform: uppercase;
    }
    
    .visualizer-controls button.active { color: var(--secondary); }
    
    .playlist-toggle {
      width: 100%;
      background: none;
      border: none;
      padding: 0.75rem;
      color: var(--text);
      font-family: inherit;
      cursor: pointer;
      text-transform: uppercase;
    }
    
    .playlist-container {
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.2);
    }
    
    .playlist-item {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 1rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .playlist-item:hover { background: rgba(255, 255, 255, 0.05); }
    .playlist-item.active { background: rgba(255, 75, 0, 0.1); }
    .playlist-item.active span:last-child { color: var(--primary); }
  </style>
</head>
// Replace your existing neural network background code with this
// DOM elements
const $ = id => document.getElementById(id);
const musicPlayer = $('musicPlayer');
const playPauseBtn = $('playPause');
const canvas = $('visualizer');
const ctx = canvas.getContext('2d');
const progressBar = $('progressBar');
const progressContainer = $('progressContainer');

// Background neural network setup
const bgCanvas = $('background-canvas');
const bgCtx = bgCanvas.getContext('2d');

// Set canvas dimensions
canvas.width = canvas.offsetWidth;
canvas.height = canvas.offsetHeight;
bgCanvas.width = window.innerWidth;
bgCanvas.height = window.innerHeight;

// Track list
const tracks = [
  { src: 'track1.wav', title: 'Liquid Dreams' },
  { src: 'track2.wav', title: 'Neon Flow' },
  { src: 'track3.wav', title: 'Cosmic Wave' },
  { src: 'track4.wav', title: 'Digital Sunrise' },
  { src: 'track5.wav', title: 'Quantum Beat' },
  { src: 'track6.wav', title: 'Cyberspace Odyssey' },
  { src: 'track7.wav', title: 'Neural Network' },
  { src: 'track8.wav', title: 'Binary Echoes' },
  { src: 'track9.wav', title: 'Virtual Reality' },
  { src: 'track10.wav', title: 'Holographic Memory' },
  { src: 'track11.wav', title: 'Singularity' },
  { src: 'track12.wav', title: 'Electric Dreams' },
  { src: 'track13.wav', title: 'Synthwave Journey' },
  { src: 'track14.wav', title: 'Galactic Pulse' },
  { src: 'track15.wav', title: 'Cyber Dawn' },
  { src: 'track16.wav', title: 'Ethereal Code' },
  { src: 'track17.mp3', title: 'Alternatives' },
  { src: 'track18.wav', title: 'Astral Projection' },
  { src: 'track19.wav', title: 'Plasma Field' },
  { src: 'track20.wav', title: 'Quantum Resonance' }
];

// State variables
let currentTrackIndex = 0;
let currentVisualizer = 1;
let animationId = null;
let bgAnimationId = null;
let audioContext, analyser, source, dataArray, bufferLength;

// 3D Neural Network State
const nodes = [];
const links = [];
const NODE_COUNT = 80;
const DEPTH = 200;
let rotation = 0;
let reactivity = 0;
let pulseIntensity = 0;
let cameraZ = 400;

// Color schemes (blue to red gradients)
const colorSchemes = [
  { start: [0, 120, 255], end: [255, 50, 120], connection: [140, 80, 200] },
  { start: [50, 200, 255], end: [255, 60, 80], connection: [180, 100, 255] },
  { start: [0, 180, 240], end: [220, 40, 100], connection: [120, 140, 255] },
];
let currentColorScheme = 0;
let transitionProgress = 0;
let targetColorScheme = 0;
let isTransitioning = false;

// Helper functions
const formatTime = s => `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;
const lerp = (a, b, t) => a + (b - a) * t;
const map = (value, min1, max1, min2, max2) => min2 + (max2 - min2) * ((value - min1) / (max1 - min1));
const getColor = (start, end, t) => {
  return `rgb(${
    Math.floor(lerp(start[0], end[0], t))},${
    Math.floor(lerp(start[1], end[1], t))},${
    Math.floor(lerp(start[2], end[2], t))})`;
};

// Audio context initialization
function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    source = audioContext.createMediaElementSource(musicPlayer);
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    analyser.fftSize = 512;
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
  }
}

// 3D projection function
function project3D(x, y, z) {
  const fov = 450;
  const scale = fov / (fov + z + cameraZ);
  return {
    x: (x * scale) + bgCanvas.width / 2,
    y: (y * scale) + bgCanvas.height / 2,
    scale: scale
  };
}

// Initialize 3D neural network
function initNeuralNetwork() {
  nodes.length = 0;
  links.length = 0;
  
  // Create nodes in 3D space
  for (let i = 0; i < NODE_COUNT; i++) {
    // Create nodes in a roughly spherical arrangement
    const phi = Math.random() * Math.PI * 2;
    const theta = Math.random() * Math.PI;
    const radius = 50 + Math.random() * 100;
    
    // Convert spherical to cartesian coordinates
    const x = radius * Math.sin(theta) * Math.cos(phi);
    const y = radius * Math.sin(theta) * Math.sin(phi);
    const z = radius * Math.cos(theta);
    
    nodes.push({
      x, y, z,
      size: Math.random() * 2 + 2,
      pulse: 0,
      speed: Math.random() * 0.02 + 0.01,
      phase: Math.random() * Math.PI * 2,
      frequency: Math.random() * 0.05 + 0.02
    });
  }
  
  // Create connections between nearby nodes
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    
    // Find closest nodes
    const distances = nodes.map((other, idx) => {
      if (i === idx) return Infinity;
      const dx = node.x - other.x;
      const dy = node.y - other.y;
      const dz = node.z - other.z;
      return {
        index: idx,
        distance: Math.sqrt(dx*dx + dy*dy + dz*dz)
      };
    }).sort((a, b) => a.distance - b.distance);
    
    // Connect to closest 3-5 nodes
    const connectCount = Math.floor(Math.random() * 3) + 3;
    for (let j = 0; j < connectCount && j < 5; j++) {
      links.push({
        from: i,
        to: distances[j].index,
        strength: Math.random() * 0.5 + 0.2,
        signal: Math.random(),
        speed: Math.random() * 0.02 + 0.01
      });
    }
  }
}

// Render 3D neural network background
function renderNeuralBackground() {
  if (!audioContext) {
    bgAnimationId = requestAnimationFrame(renderNeuralBackground);
    return;
  }
  
  bgAnimationId = requestAnimationFrame(renderNeuralBackground);
  analyser.getByteFrequencyData(dataArray);
  
  // Calculate audio reactivity - more weight to lower frequencies
  let bassPower = 0;
  let midPower = 0;
  for (let i = 0; i < bufferLength; i++) {
    if (i < bufferLength * 0.1) {
      bassPower += dataArray[i];
    } else if (i < bufferLength * 0.5) {
      midPower += dataArray[i];
    }
  }
  
  // Normalize
  bassPower = bassPower / (bufferLength * 0.1 * 255);
  midPower = midPower / (bufferLength * 0.4 * 255);
  reactivity = bassPower * 0.7 + midPower * 0.3;
  
  // Update pulse intensity with smoothing
  pulseIntensity = pulseIntensity * 0.95 + reactivity * 0.05;
  
  // Handle color scheme transitions
  if (isTransitioning) {
    transitionProgress += 0.02;
    if (transitionProgress >= 1) {
      currentColorScheme = targetColorScheme;
      isTransitioning = false;
      transitionProgress = 0;
    }
  } else if (Math.random() < 0.001 + reactivity * 0.01) {
    // Trigger color transition based on audio intensity
    targetColorScheme = (currentColorScheme + 1) % colorSchemes.length;
    isTransitioning = true;
    transitionProgress = 0;
  }
  
  // Clear with fade effect for trails
  bgCtx.fillStyle = 'rgba(6, 8, 12, 0.15)';
  bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
  
  // Rotate the entire network
  rotation += 0.002 + reactivity * 0.001;
  const sinRot = Math.sin(rotation);
  const cosRot = Math.cos(rotation);
  
  // Camera "breathes" with the music
  cameraZ = 400 - reactivity * 50;
  
  // Compute projected coordinates for all nodes
  const projectedNodes = nodes.map(node => {
    // Apply rotation
    const x1 = node.x * cosRot - node.z * sinRot;
    const z1 = node.z * cosRot + node.x * sinRot;
    
    // Add some motion based on audio
    const motionX = x1 + Math.sin(node.phase + Date.now() * node.frequency) * 5 * reactivity;
    const motionY = node.y + Math.cos(node.phase + Date.now() * node.frequency) * 5 * reactivity;
    const motionZ = z1;
    
    // Project to 2D
    const projected = project3D(motionX, motionY, motionZ);
    projected.originalZ = motionZ;
    
    // Calculate node pulse based on audio and depth
    const depthFactor = map(motionZ, -DEPTH, DEPTH, 0.2, 1);
    const pulseFactor = pulseIntensity * depthFactor * 5;
    projected.size = (node.size + pulseFactor) * projected.scale;
    
    // Calculate color based on depth
    let colorT = map(motionZ, -DEPTH, DEPTH, 0, 1);
    if (isTransitioning) {
      // Blend between color schemes during transition
      const currScheme = colorSchemes[currentColorScheme];
      const nextScheme = colorSchemes[targetColorScheme];
      const blendedStart = [
        lerp(currScheme.start[0], nextScheme.start[0], transitionProgress),
        lerp(currScheme.start[1], nextScheme.start[1], transitionProgress),
        lerp(currScheme.start[2], nextScheme.start[2], transitionProgress)
      ];
      const blendedEnd = [
        lerp(currScheme.end[0], nextScheme.end[0], transitionProgress),
        lerp(currScheme.end[1], nextScheme.end[1], transitionProgress),
        lerp(currScheme.end[2], nextScheme.end[2], transitionProgress)
      ];
      projected.color = getColor(blendedStart, blendedEnd, colorT);
    } else {
      const scheme = colorSchemes[currentColorScheme];
      projected.color = getColor(scheme.start, scheme.end, colorT);
    }
    
    return projected;
  });
  
  // Sort by Z for proper depth layering
  const sortedIndices = projectedNodes.map((node, i) => i)
    .sort((a, b) => nodes[a].z - nodes[b].z);
  
  // Draw connections first (behind nodes)
  links.forEach(link => {
    const from = projectedNodes[link.from];
    const to = projectedNodes[link.to];
    
    // Calculate link opacity based on distance and Z-depth
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Only draw connections if nodes are visible and not too far apart
    if (from.scale > 0.1 && to.scale > 0.1 && distance < bgCanvas.width * 0.5) {
      // Average Z position determines connection color
      const avgZ = (nodes[link.from].z + nodes[link.to].z) / 2;
      const depthFactor = map(avgZ, -DEPTH, DEPTH, 0.1, 0.6);
      
      // Update signal position based on audio
      link.signal = (link.signal + link.speed * (1 + reactivity)) % 1;
      
      // Calculate signal position
      const signalX = from.x + dx * link.signal;
      const signalY = from.y + dy * link.signal;
      
      // Draw connection with gradient
      const gradient = bgCtx.createLinearGradient(from.x, from.y, to.x, to.y);
      gradient.addColorStop(0, from.color);
      gradient.addColorStop(1, to.color);
      
      bgCtx.strokeStyle = gradient;
      bgCtx.globalAlpha = depthFactor * link.strength;
      bgCtx.lineWidth = 1 + reactivity;
      bgCtx.beginPath();
      bgCtx.moveTo(from.x, from.y);
      bgCtx.lineTo(to.x, to.y);
      bgCtx.stroke();
      
      // Draw signal pulse
      if (reactivity > 0.1) {
        // Get color for signal pulse
        let connectionColor;
        if (isTransitioning) {
          const currColor = colorSchemes[currentColorScheme].connection;
          const nextColor = colorSchemes[targetColorScheme].connection;
          connectionColor = [
            lerp(currColor[0], nextColor[0], transitionProgress),
            lerp(currColor[1], nextColor[1], transitionProgress),
            lerp(currColor[2], nextColor[2], transitionProgress)
          ];
        } else {
          connectionColor = colorSchemes[currentColorScheme].connection;
        }
        
        bgCtx.fillStyle = `rgb(${connectionColor[0]}, ${connectionColor[1]}, ${connectionColor[2]})`;
        bgCtx.globalAlpha = depthFactor * reactivity;
        bgCtx.beginPath();
        bgCtx.arc(signalX, signalY, 1.5 + reactivity * 2, 0, Math.PI * 2);
        bgCtx.fill();
      }
      
      bgCtx.globalAlpha = 1;
    }
  });
  
  // Draw nodes in sorted order (back to front)
  sortedIndices.forEach(i => {
    const proj = projectedNodes[i];
    const node = nodes[i];
    
    // Only draw if node is large enough to be visible
    if (proj.size > 0.5) {
      // Draw node with glow effect
      const glowSize = proj.size * (1 + reactivity);
      const gradient = bgCtx.createRadialGradient(
        proj.x, proj.y, 0,
        proj.x, proj.y, glowSize * 2
      );
      
      gradient.addColorStop(0, proj.color);
      gradient.addColorStop(0.5, proj.color.replace('rgb', 'rgba').replace(')', ', 0.3)'));
      gradient.addColorStop(1, proj.color.replace('rgb', 'rgba').replace(')', ', 0)'));
      
      bgCtx.fillStyle = gradient;
      bgCtx.beginPath();
      bgCtx.arc(proj.x, proj.y, glowSize, 0, Math.PI * 2);
      bgCtx.fill();
      
      // Core of the node
      bgCtx.fillStyle = proj.color;
      bgCtx.beginPath();
      bgCtx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
      bgCtx.fill();
    }
  });
}

// Track management
function loadTrack(index) {
  index = (index + tracks.length) % tracks.length;
  currentTrackIndex = index;
  musicPlayer.src = tracks[index].src;
  $('trackTitle').textContent = tracks[index].title;
  $('currentTrackNum').textContent = index + 1;
  
  document.querySelectorAll('.playlist-item').forEach(item => {
    item.classList.toggle('active', item.dataset.index == index);
  });
  
  const activeItem = document.querySelector(`.playlist-item[data-index="${index}"]`);
  if (activeItem) activeItem.scrollIntoView({behavior: 'smooth', block: 'nearest'});
  
  musicPlayer.load();
}

function createPlaylist() {
  const playlist = $('playlist');
  playlist.innerHTML = '';
  
  tracks.forEach((track, i) => {
    const item = document.createElement('div');
    item.className = 'playlist-item' + (i === currentTrackIndex ? ' active' : '');
    item.dataset.index = i;
    
    item.innerHTML = `
      <span>${(i + 1).toString().padStart(2, '0')}</span>
      <span>${track.title}</span>
    `;
    
    item.addEventListener('click', () => {
      loadTrack(i);
      playTrack();
    });
    
    playlist.appendChild(item);
  });
}

// Playback controls
function playTrack() {
  initAudio();
  audioContext.resume().then(() => {
    musicPlayer.play();
    playPauseBtn.textContent = 'Pause';
    if (!animationId) renderVisualizer();
  });
}

function pauseTrack() {
  musicPlayer.pause();
  playPauseBtn.textContent = 'Play';
}

// Progress bar update
function updateProgress() {
  if (!musicPlayer.duration) return;
  
  progressBar.style.width = `${(musicPlayer.currentTime / musicPlayer.duration) * 100}%`;
  $('currentTime').textContent = formatTime(musicPlayer.currentTime);
  $('totalTime').textContent = formatTime(musicPlayer.duration);
}

// Initialize neural network
window.addEventListener('resize', () => {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
});

// Initialize neural network on load
initNeuralNetwork();
renderNeuralBackground();

    // Visualizer rendering functions
    function renderVisualizer() {
      if (!audioContext) return;
      animationId = requestAnimationFrame(renderVisualizer);
      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const vizFuncs = [
        drawHolographicBars,
        drawQuantumCircles,
        drawNeuralWave,
        drawGalacticStars,
        draw4DSpectrum
      ];
      
      vizFuncs[currentVisualizer - 1]();
    }

  function drawHolographicBars() {
  const barWidth = (canvas.width / bufferLength) * 2.5;
  
  // Create a time-based shimmer effect
  const time = Date.now() * 0.001;
  
  for (let i = 0, x = 0; i < bufferLength; i++, x += barWidth + 1) {
    const barHeight = dataArray[i];
    
    // Add a pulsing effect based on audio data and time
    const pulseIntensity = 0.2 * Math.sin(time + i * 0.1) + 1;
    const adjustedHeight = barHeight * pulseIntensity;
    
    // Create a more vibrant holographic gradient
    const gradient = ctx.createLinearGradient(x, canvas.height, x, canvas.height - adjustedHeight);
    
    // Dynamic color based on frequency and time
    const hue1 = (barHeight + time * 20) % 360;
    const hue2 = (hue1 + 180) % 360;
    
    gradient.addColorStop(0, `hsla(${hue1}, 100%, 70%, 0.9)`);
    gradient.addColorStop(0.5, `hsla(${(hue1 + 60) % 360}, 100%, 60%, 0.7)`);
    gradient.addColorStop(1, `hsla(${hue2}, 100%, 80%, 0.3)`);
    
    ctx.fillStyle = gradient;
    
    // Draw bar with rounded top
    ctx.beginPath();
    ctx.moveTo(x, canvas.height);
    ctx.lineTo(x, canvas.height - adjustedHeight / 2);
    ctx.arc(x + barWidth / 2, canvas.height - adjustedHeight / 2, barWidth / 2, Math.PI, 0, false);
    ctx.lineTo(x + barWidth, canvas.height);
    ctx.closePath();
    ctx.fill();
    
    // Add holographic glow effect
    ctx.shadowColor = `hsla(${hue1}, 100%, 70%, 0.7)`;
    ctx.shadowBlur = 15 * (barHeight / 255);
    
    // Add shimmering stroke
    const strokeOpacity = 0.3 + 0.5 * Math.sin(time * 3 + i * 0.2);
    ctx.strokeStyle = `rgba(255, 255, 255, ${strokeOpacity})`;
    ctx.lineWidth = 0.5 + (barHeight / 255) * 1.5;
    ctx.stroke();
    
    // Reset shadow for next iteration
    ctx.shadowBlur = 0;
    
    // Add occasional vertical light streak for extra dimension
    if (Math.random() < 0.05) {
      ctx.beginPath();
      const streakX = x + barWidth * Math.random();
      ctx.strokeStyle = `rgba(255, 255, 255, 0.7)`;
      ctx.lineWidth = 0.5;
      ctx.moveTo(streakX, canvas.height);
      ctx.lineTo(streakX, canvas.height - adjustedHeight * 1.2);
      ctx.stroke();
    }
  }
}
   function drawQuantumCircles() {
  // Use performance time to drive dynamic animations
  const t = performance.now() / 1000;
  for (let i = 0; i < bufferLength; i++) {
    // Base angle with a slight time-based offset for subtle motion
    const angle = (Math.PI * 2 * i / bufferLength) + (Math.sin(t + i) * 0.05);
    // Base radius scaled from audio data with an additional pulsating factor
    const baseRadius = dataArray[i] / 255 * Math.min(canvas.width, canvas.height) / 4;
    const pulsate = 1 + 0.2 * Math.sin(t * 3 + i);
    const radius = baseRadius * pulsate;
    // Calculate circle center positions around the canvas center
    const x = canvas.width / 2 + Math.cos(angle) * radius;
    const y = canvas.height / 2 + Math.sin(angle) * radius;
    
    // Create an enhanced radial gradient with three stops for smooth color transitions
    const hue = (i * 360 / bufferLength + t * 40) % 360;
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius / 5);
    gradient.addColorStop(0, `hsla(${hue}, 100%, 60%, 1)`);
    gradient.addColorStop(0.7, `hsla(${(hue + 30) % 360}, 100%, 55%, 0.7)`);
    gradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 50%, 0)`);

    // Draw the primary circle with the custom gradient
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius / 5, 0, Math.PI * 2);
    ctx.fill();

    // Use a sine-based modulation for stroke opacity for smooth, rhythmic transitions
    const strokeOpacity = (Math.sin(t + i / 10) * 0.5 + 0.5).toFixed(2);
    ctx.strokeStyle = `rgba(255, 255, 255, ${strokeOpacity})`;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(canvas.width / 2, canvas.height / 2);
    ctx.stroke();

    // Add a secondary, larger arc for that extra uncanny glow effect
    ctx.beginPath();
    ctx.arc(x, y, radius / 4, 0, Math.PI * 2);
    ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${strokeOpacity})`;
    ctx.stroke();
  }
}


    function drawNeuralWave() {
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();

      const sliceWidth = canvas.width / bufferLength;
      
      for (let i = 0, x = 0; i < bufferLength; i++, x += sliceWidth) {
        const v = dataArray[i] / 128.0;
        const y = v * canvas.height / 2;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);

        ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, 255, 0.8)`;
        ctx.beginPath();
        ctx.arc(x, y, v * 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();
    }

    function drawGalacticStars() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'lighter';
      
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const dataIndex = Math.floor((i / 100) * bufferLength);
        const radius = (dataArray[dataIndex] / 255) * 3 + 1;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${dataArray[dataIndex]/255})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
      
      ctx.globalCompositeOperation = 'source-over';
    }

    function draw4DSpectrum() {
      const barWidth = canvas.width / bufferLength;
      
      for (let i = 0; i < bufferLength; i++) {
        const barHeight = dataArray[i];
        const x = i * barWidth;
        const hue = i / bufferLength * 360;

        const gradient = ctx.createLinearGradient(x, canvas.height, x, canvas.height - barHeight);
        gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 1)`);
        gradient.addColorStop(1, `hsla(${hue}, 100%, 80%, 0.2)`);

        ctx.fillStyle = gradient;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

        ctx.globalAlpha = Math.sin(Date.now() / 1000 + i / bufferLength * Math.PI * 2) * 0.5 + 0.5;
        ctx.fillStyle = `hsla(${(hue + 180) % 360}, 100%, 50%, 0.5)`;
        ctx.fillRect(x, canvas.height - barHeight * 0.5, barWidth, barHeight * 0.5);
        ctx.globalAlpha = 1;
      }
    }

    // Event Handlers
    function updateVisualizerButtons() {
      document.querySelectorAll('.visualizer-controls button').forEach((btn, i) => {
        btn.classList.toggle('active', i + 1 === currentVisualizer);
      });
    }

    // Event listeners
    playPauseBtn.addEventListener('click', () => musicPlayer.paused ? playTrack() : pauseTrack());
    $('prevTrack').addEventListener('click', () => { loadTrack(currentTrackIndex - 1); playTrack(); });
    $('nextTrack').addEventListener('click', () => { loadTrack(currentTrackIndex + 1); playTrack(); });
    musicPlayer.addEventListener('ended', () => { loadTrack(currentTrackIndex + 1); playTrack(); });
    musicPlayer.addEventListener('timeupdate', updateProgress);
    musicPlayer.addEventListener('durationchange', () => { $('totalTime').textContent = formatTime(musicPlayer.duration); });
    
    progressContainer.addEventListener('click', e => {
      musicPlayer.currentTime = (e.offsetX / progressContainer.offsetWidth) * musicPlayer.duration;
    });
    
    $('playlistToggle').addEventListener('click', () => {
      const playlist = $('playlist');
      const isHidden = playlist.style.display === 'none';
      playlist.style.display = isHidden ? 'block' : 'none';
      $('playlistToggle').textContent = isHidden ? 'Hide Playlist' : 'Playlist';
    });

    // Visualizer controls
    document.querySelectorAll('.visualizer-controls button').forEach((btn, i) => {
      btn.addEventListener('click', () => {
        currentVisualizer = i + 1;
        updateVisualizerButtons();
      });
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      initNeuralNetwork();
    });

    // Initialize
    loadTrack(currentTrackIndex);
    createPlaylist();
    initNeuralNetwork();
    renderNeuralBackground();
  </script>
</body>
</html>
